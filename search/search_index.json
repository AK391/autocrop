{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"autocrop Perfect for profile picture processing for your website or batch work for ID cards, autocrop will output images centered around the biggest face detected. Installation Simple! pip install autocrop Use Autocrop can be used from the command line or directly from Python API . From the command line usage : [ - h ] [ - o OUTPUT ] [ - i INPUT ] [ - w WIDTH ] [ - H HEIGHT ] [ - v ] Automatically crops faces from batches of pictures optional arguments : - h , --help Show this help message and exit - o , --output, -p, --path Folder where cropped images will be placed . Default : current working directory - r , --reject Folder where images without detected faces will be placed . Default : same as output directory - i , --input Folder where images to crop are located . Default : current working directory - w , --width Width of cropped files in px . Default = 500 - H , --height Height of cropped files in px . Default = 500 --facePercent Percentage of Face height to image height ( zoom factor ) --padUp Padding up value compared to padDown . Default = 50 --padDown Padding down value compared to padDown . Default = 50 --padLeft Padding left value compared to padRight . Default = 50 --padRight Padding right value compared to padLeft . Default = 50 - v , --version Show program ' s version number and exit Examples Crop every image in the pics folder, resize them to 400 px squares, and output them in the crop directory: autocrop -i pics -o crop -w 400 -H 400 . Images where a face can't be detected will be left in crop . Same as above, but output the images with undetected faces to the reject folder: autocrop -i pics -o crop -r nofaces -w 400 -H 400 . Same as the first example, but add more padding at the bottom: autocrop -i pics -o crop -w 400 -H 400 --facePercent 50 --padUp 20 --padDown 50 . If no output folder is added, asks for confirmation and destructively crops images in-place. From Python Import the Cropper class, set some parameters (optional), and start cropping. The crop method accepts filepaths or np.ndarray , and returns Numpy arrays. These are easily handled with PIL . from PIL import Image from autocrop import Cropper cropper = Cropper () # Get a Numpy array of the cropped image cropped_array = cropper . Cropper ( 'portrait.png' ) # Save the cropped image with PIL cropped_image = Image . fromarray ( cropped_image ) cropped_image . save ( 'cropped.png' ) Supported file types The following file types are supported: EPS files ( .eps ) GIF files ( .gif ) (only the first frame of an animated GIF is used) JPEG 2000 files ( .j2k , .j2p , .jp2 , .jpx ) JPEG files ( .jpeg , .jpg , .jpe ) LabEye IM files ( .im ) macOS ICNS files ( .icns ) Microsoft Paint bitmap files ( .msp ) PCX files ( .pcx ) Portable Network Graphics ( .png ) Portable Pixmap files ( .pbm , .pgm , .ppm ) SGI files ( .sgi ) SPIDER files ( .spi ) TGA files ( .tga ) TIFF files ( .tif , .tiff ) WebP ( .webp ) Windows bitmap files ( .bmp , .dib ) Windows ICO files ( .ico ) X bitmap files ( .xbm ) Gotchas Autocrop uses OpenCV to perform face detection, which is installed through binary wheels . If you already have OpenCV 3+ installed, you may wish to uninstall the additional OpenCV installation: pip uninstall opencv-python . Installing directly In some cases, you may wish the package directly, instead of through PyPI : cd ~ git clone https://github.com/leblancfg/autocrop cd autocrop pip install . conda Development of a conda-forge package for the Anaconda Python distribution is also currently slated for development. Please leave feedback on issue #7 if you are insterested in helping out. Requirements Best practice for your projects is of course to use virtual environments . At the very least, you will need to have pip installed . Autocrop is currently being tested on: * Python: - 2.7 - 3.4 - 3.5 - 3.6 * OS: - Linux - macOS - Windows More Info Check out: * http://docs.opencv.org/master/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0 * http://docs.opencv.org/master/d5/daf/tutorial_py_histogram_equalization.html#gsc.tab=0 Adapted from: * http://photo.stackexchange.com/questions/60411/how-can-i-batch-crop-based-on-face-location Contributing Although autocrop is essentially a CLI wrapper around a single OpenCV function, it is actively developed. It has active users throughout the world. If you would like to contribute, please consult the contribution docs .","title":"Home"},{"location":"#autocrop","text":"Perfect for profile picture processing for your website or batch work for ID cards, autocrop will output images centered around the biggest face detected.","title":"autocrop"},{"location":"#installation","text":"Simple! pip install autocrop","title":"Installation"},{"location":"#use","text":"Autocrop can be used from the command line or directly from Python API .","title":"Use"},{"location":"#from-the-command-line","text":"usage : [ - h ] [ - o OUTPUT ] [ - i INPUT ] [ - w WIDTH ] [ - H HEIGHT ] [ - v ] Automatically crops faces from batches of pictures optional arguments : - h , --help Show this help message and exit - o , --output, -p, --path Folder where cropped images will be placed . Default : current working directory - r , --reject Folder where images without detected faces will be placed . Default : same as output directory - i , --input Folder where images to crop are located . Default : current working directory - w , --width Width of cropped files in px . Default = 500 - H , --height Height of cropped files in px . Default = 500 --facePercent Percentage of Face height to image height ( zoom factor ) --padUp Padding up value compared to padDown . Default = 50 --padDown Padding down value compared to padDown . Default = 50 --padLeft Padding left value compared to padRight . Default = 50 --padRight Padding right value compared to padLeft . Default = 50 - v , --version Show program ' s version number and exit","title":"From the command line"},{"location":"#examples","text":"Crop every image in the pics folder, resize them to 400 px squares, and output them in the crop directory: autocrop -i pics -o crop -w 400 -H 400 . Images where a face can't be detected will be left in crop . Same as above, but output the images with undetected faces to the reject folder: autocrop -i pics -o crop -r nofaces -w 400 -H 400 . Same as the first example, but add more padding at the bottom: autocrop -i pics -o crop -w 400 -H 400 --facePercent 50 --padUp 20 --padDown 50 . If no output folder is added, asks for confirmation and destructively crops images in-place.","title":"Examples"},{"location":"#from-python","text":"Import the Cropper class, set some parameters (optional), and start cropping. The crop method accepts filepaths or np.ndarray , and returns Numpy arrays. These are easily handled with PIL . from PIL import Image from autocrop import Cropper cropper = Cropper () # Get a Numpy array of the cropped image cropped_array = cropper . Cropper ( 'portrait.png' ) # Save the cropped image with PIL cropped_image = Image . fromarray ( cropped_image ) cropped_image . save ( 'cropped.png' )","title":"From Python"},{"location":"#supported-file-types","text":"The following file types are supported: EPS files ( .eps ) GIF files ( .gif ) (only the first frame of an animated GIF is used) JPEG 2000 files ( .j2k , .j2p , .jp2 , .jpx ) JPEG files ( .jpeg , .jpg , .jpe ) LabEye IM files ( .im ) macOS ICNS files ( .icns ) Microsoft Paint bitmap files ( .msp ) PCX files ( .pcx ) Portable Network Graphics ( .png ) Portable Pixmap files ( .pbm , .pgm , .ppm ) SGI files ( .sgi ) SPIDER files ( .spi ) TGA files ( .tga ) TIFF files ( .tif , .tiff ) WebP ( .webp ) Windows bitmap files ( .bmp , .dib ) Windows ICO files ( .ico ) X bitmap files ( .xbm )","title":"Supported file types"},{"location":"#gotchas","text":"Autocrop uses OpenCV to perform face detection, which is installed through binary wheels . If you already have OpenCV 3+ installed, you may wish to uninstall the additional OpenCV installation: pip uninstall opencv-python .","title":"Gotchas"},{"location":"#installing-directly","text":"In some cases, you may wish the package directly, instead of through PyPI : cd ~ git clone https://github.com/leblancfg/autocrop cd autocrop pip install .","title":"Installing directly"},{"location":"#conda","text":"Development of a conda-forge package for the Anaconda Python distribution is also currently slated for development. Please leave feedback on issue #7 if you are insterested in helping out.","title":"conda"},{"location":"#requirements","text":"Best practice for your projects is of course to use virtual environments . At the very least, you will need to have pip installed . Autocrop is currently being tested on: * Python: - 2.7 - 3.4 - 3.5 - 3.6 * OS: - Linux - macOS - Windows","title":"Requirements"},{"location":"#more-info","text":"Check out: * http://docs.opencv.org/master/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0 * http://docs.opencv.org/master/d5/daf/tutorial_py_histogram_equalization.html#gsc.tab=0 Adapted from: * http://photo.stackexchange.com/questions/60411/how-can-i-batch-crop-based-on-face-location","title":"More Info"},{"location":"#contributing","text":"Although autocrop is essentially a CLI wrapper around a single OpenCV function, it is actively developed. It has active users throughout the world. If you would like to contribute, please consult the contribution docs .","title":"Contributing"},{"location":"CONTRIBUTING/","text":"Contributing All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Please follow these steps: Fork the autocrop repository to your personal GitHub account and clone it locally Install the development setup (see section below) Branch off of master for every change you want to make Develop changes on your branch Test your changes (see section below) Modify the tests and documentation as necessary When your changes are ready, make a pull request to the upstream autocrop repository Development Setup This project works with virtualenv . To start things off, run: $ python3 -m venv env $ source env/bin/activate Then, run: $ pip install -U setuptools $ pip install -r requirements-test.txt $ pip install -e . You can then run autocrop like so: $ autocrop As long as the virtual environment has been activated, this will command will use the files in your local Git checkout. This makes it super easy to work on the code and test your changes. To set up your virtual environment again in future, just run: $ source env/bin/activate Tests Pull requests are tested using continuous integration (CI) which will green-light changes. Specifically, we: Use flake8 for coding style tests Run a test suite using pytest You can run the tests locally, like so: $ make check Contact If you have any questions, please email me at leblancfg@gmail.com .","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Please follow these steps: Fork the autocrop repository to your personal GitHub account and clone it locally Install the development setup (see section below) Branch off of master for every change you want to make Develop changes on your branch Test your changes (see section below) Modify the tests and documentation as necessary When your changes are ready, make a pull request to the upstream autocrop repository","title":"Contributing"},{"location":"CONTRIBUTING/#development-setup","text":"This project works with virtualenv . To start things off, run: $ python3 -m venv env $ source env/bin/activate Then, run: $ pip install -U setuptools $ pip install -r requirements-test.txt $ pip install -e . You can then run autocrop like so: $ autocrop As long as the virtual environment has been activated, this will command will use the files in your local Git checkout. This makes it super easy to work on the code and test your changes. To set up your virtual environment again in future, just run: $ source env/bin/activate","title":"Development Setup"},{"location":"CONTRIBUTING/#tests","text":"Pull requests are tested using continuous integration (CI) which will green-light changes. Specifically, we: Use flake8 for coding style tests Run a test suite using pytest You can run the tests locally, like so: $ make check","title":"Tests"},{"location":"CONTRIBUTING/#contact","text":"If you have any questions, please email me at leblancfg@gmail.com .","title":"Contact"},{"location":"changelog/","text":"Autocrop changelog 0.3.2 Changes Autocrop now prints the filename of images where face detection failed Internal refactoring and more tests 0.3.1 Changes Add -r , --reject flag to specify directory where the images that autocrop couldn't find a face in are directed to. Instead of having the target files copied then cropped, they are instead cropped and saved to their respective target folder. 0.3.0 Changes Added support for padding ( padLeft , etc.) in the CLI. Bugfix Fixed warp on crop for -w and -h values 0.2.0 Changes Add -o , --output flag to specify directory where cropped images are to be dumped. Error out if output folder set to current directory, i.e. -o . If directory doesn't exist yet, create it. If no face can be found in an image in batch, it is still copied over to -o folder. If no output folder is added, ask for confirmation ([Y]/n), and destructively crop images in-place. Use -i , --input flags as synonyms for -p or --path : symmetrical in meaning to \"output\". Is now standard nomenclature in documentation. --input or --path flag is now optional. Standard behaviour without input folder is to non-recursively process all images in immediate folder, i.e. -p . as currently implemented. Breaks Removed all mentions of the hard-coded 'bkp' and 'crop' folders Calling autocrop without specifying an input path, i.e. autocrop does not look for the 'images' folder anymore.","title":"Changelog"},{"location":"changelog/#autocrop-changelog","text":"","title":"Autocrop changelog"},{"location":"changelog/#032","text":"","title":"0.3.2"},{"location":"changelog/#changes","text":"Autocrop now prints the filename of images where face detection failed Internal refactoring and more tests","title":"Changes"},{"location":"changelog/#031","text":"","title":"0.3.1"},{"location":"changelog/#changes_1","text":"Add -r , --reject flag to specify directory where the images that autocrop couldn't find a face in are directed to. Instead of having the target files copied then cropped, they are instead cropped and saved to their respective target folder.","title":"Changes"},{"location":"changelog/#030","text":"","title":"0.3.0"},{"location":"changelog/#changes_2","text":"Added support for padding ( padLeft , etc.) in the CLI.","title":"Changes"},{"location":"changelog/#bugfix","text":"Fixed warp on crop for -w and -h values","title":"Bugfix"},{"location":"changelog/#020","text":"","title":"0.2.0"},{"location":"changelog/#changes_3","text":"Add -o , --output flag to specify directory where cropped images are to be dumped. Error out if output folder set to current directory, i.e. -o . If directory doesn't exist yet, create it. If no face can be found in an image in batch, it is still copied over to -o folder. If no output folder is added, ask for confirmation ([Y]/n), and destructively crop images in-place. Use -i , --input flags as synonyms for -p or --path : symmetrical in meaning to \"output\". Is now standard nomenclature in documentation. --input or --path flag is now optional. Standard behaviour without input folder is to non-recursively process all images in immediate folder, i.e. -p . as currently implemented.","title":"Changes"},{"location":"changelog/#breaks","text":"Removed all mentions of the hard-coded 'bkp' and 'crop' folders Calling autocrop without specifying an input path, i.e. autocrop does not look for the 'images' folder anymore.","title":"Breaks"},{"location":"reference/autocrop/","text":"Module autocrop Image cropping module for Python with face detection Autocrop is a Python module that provides a simple and efficient method of cropping images of people around their faces. See https://leblancfg.com/autocrop for more documentation. View Source # -*- coding: utf-8 -*- # flake8: noqa import os import sys from .autocrop import Cropper from .cli import command_line_interface from .__version__ import __version__ __doc__ = \"\"\" Image cropping module for Python with face detection ==================================================== Autocrop is a Python module that provides a simple and efficient method of cropping images of people around their faces. See https://leblancfg.com/autocrop for more documentation. \"\"\" # Inject vendored directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"vendor\" ]) ) sys . path . insert ( 0 , v_path ) # Inject patched directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"patched\" ]) ) sys . path . insert ( 0 , v_path ) if __name__ == \"__main__\" : command_line_interface () Sub-modules autocrop.autocrop autocrop.cli autocrop.constants Variables v_path","title":"Index"},{"location":"reference/autocrop/#module-autocrop","text":"","title":"Module autocrop"},{"location":"reference/autocrop/#image-cropping-module-for-python-with-face-detection","text":"Autocrop is a Python module that provides a simple and efficient method of cropping images of people around their faces. See https://leblancfg.com/autocrop for more documentation. View Source # -*- coding: utf-8 -*- # flake8: noqa import os import sys from .autocrop import Cropper from .cli import command_line_interface from .__version__ import __version__ __doc__ = \"\"\" Image cropping module for Python with face detection ==================================================== Autocrop is a Python module that provides a simple and efficient method of cropping images of people around their faces. See https://leblancfg.com/autocrop for more documentation. \"\"\" # Inject vendored directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"vendor\" ]) ) sys . path . insert ( 0 , v_path ) # Inject patched directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"patched\" ]) ) sys . path . insert ( 0 , v_path ) if __name__ == \"__main__\" : command_line_interface ()","title":"Image cropping module for Python with face detection"},{"location":"reference/autocrop/#sub-modules","text":"autocrop.autocrop autocrop.cli autocrop.constants","title":"Sub-modules"},{"location":"reference/autocrop/#variables","text":"v_path","title":"Variables"},{"location":"reference/autocrop/autocrop/","text":"Module autocrop.autocrop View Source # -*- coding: utf-8 -*- from __future__ import print_function , division import cv2 import numpy as np import os import sys from PIL import Image from .constants import ( MINFACE , GAMMA_THRES , GAMMA , CV2_FILETYPES , PILLOW_FILETYPES , CASCFILE , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] class ImageReadError ( BaseException ): \"\"\"Custom exception to catch an OpenCV failure type\"\"\" pass def gamma ( img , correction ): \"\"\"Simple gamma correction to brighten faces\"\"\" img = cv2 . pow ( img / 255.0 , correction ) return np . uint8 ( img * 255 ) def check_underexposed ( image , gray ): \"\"\"Returns the (cropped) image with GAMMA applied if underexposition is detected.\"\"\" uexp = cv2 . calcHist ([ gray ], [ 0 ], None , [ 256 ], [ 0 , 256 ]) if sum ( uexp [ - 26 :]) < GAMMA_THRES * sum ( uexp ): image = gamma ( image , GAMMA ) return image def check_positive_scalar ( num ): \"\"\"Returns True if value if a positive scalar\"\"\" if num > 0 and not isinstance ( num , str ) and np . isscalar ( num ): return int ( num ) raise ValueError ( \"A positive scalar is required\" ) def check_valid_pad_dict ( dic ): \"\"\"Returns dic if valid, else raises ValueError\"\"\" valid_keys = { \"pad_top\" , \"pad_right\" , \"pad_bottom\" , \"pad_left\" , } error = \"Padding arguments must use keys {} and be positive scalars\" . format ( valid_keys ) conditions = [] conditions . append ( isinstance ( dic , dict )) conditions . append ( len ( dic ) == 4 ) conditions . append ( set ( dic . keys ()) == valid_keys ) conditions . append ( all ( check_positive_scalar ( n ) for n in dic . values ())) if not all ( conditions ): raise ValueError ( error ) return dic def open_file ( input_filename ): \"\"\"Given a filename, returns a numpy array\"\"\" extension = os . path . splitext ( input_filename )[ 1 ] . lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None class Cropper ( object ): \"\"\" Crops the largest detected face from images. This class uses the CascadeClassifier from OpenCV to perform the `crop` by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: ----------- width : int, default=500 The width of the resulting array. height : int, default=500 The height of the resulting array. padding: int or dict, default=50 Number of pixels to pad around the largest detected face. Expected padding dict: { \"pad_top\": int, \"pad_right\": int, \"pad_bottom\": int, \"pad_left\": int } face_percent: int, default=50 Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. fix_gamma: bool, default=True Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. \"\"\" def __init__ ( self , width = 500 , height = 500 , padding = 50 , face_percent = 50 , fix_gamma = True ): # Size self . height = check_positive_scalar ( height ) self . width = check_positive_scalar ( width ) # Padding if isinstance ( padding , int ): pad = check_positive_scalar ( padding ) self . pad_top = pad self . pad_right = pad self . pad_bottom = pad self . pad_left = pad else : pad = check_valid_pad_dict ( padding ) self . pad_top = pad [ \"pad_top\" ] self . pad_right = pad [ \"pad_right\" ] self . pad_bottom = pad [ \"pad_bottom\" ] self . pad_left = pad [ \"pad_left\" ] # Gamma self . gamma = fix_gamma # Face Percent if face_percent > 100 : fp_error = \"The face_percent argument must be between 0 and 100\" raise ValueError ( fp_error ) self . face_percent = check_positive_scalar ( face_percent ) # XML Resource directory = os . path . dirname ( sys . modules [ \"autocrop\" ] . __file__ ) self . casc_path = os . path . join ( directory , CASCFILE ) def crop ( self , path_or_array ): \"\"\"Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- path_or_array : {str, np.ndarray} The filepath or numpy array of the image. Returns ------- image : {np.ndarray, None} A cropped numpy array if face detected, else None. \"\"\" if isinstance ( path_or_array , str ): image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h ,) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ], pos [ 2 ] : pos [ 3 ]] # Resize image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition if self . gamma : image = check_underexposed ( image , gray ) return image def _crop_positions ( self , img_height , img_width , x , y , w , h , ): \"\"\"Given face coordinates, returns coordinates for which to crop on given padding and face_percent parameters.\"\"\" # Adjust output height based on percent aspect_ratio = float ( self . width ) / float ( self . height ) height_crop = h * 100.0 / self . face_percent width_crop = aspect_ratio * float ( height_crop ) # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = float ( x - ( xpad * self . pad_left / ( self . pad_left + self . pad_right ))) h2 = float ( x + w + ( xpad * self . pad_right / ( self . pad_left + self . pad_right ))) v1 = float ( y - ( ypad * self . pad_top / ( self . pad_top + self . pad_bottom ))) v2 = float ( y + h + ( ypad * self . pad_bottom / ( self . pad_top + self . pad_bottom ))) # Determine padding ratios left_pad_ratio = self . pad_left / ( self . pad_left + self . pad_right ) right_pad_ratio = self . pad_left / ( self . pad_left + self . pad_right ) top_pad_ratio = self . pad_top / ( self . pad_top + self . pad_bottom ) bottom_pad_ratio = self . pad_bottom / ( self . pad_top + self . pad_bottom ) # Calculate largest bounds with padding ratios delta_h = 0.0 if h1 < 0 : delta_h = abs ( h1 ) / left_pad_ratio if h2 > img_width : delta_h = max ( delta_h , ( h2 - img_width ) / right_pad_ratio ) delta_v = 0.0 if delta_h <= 0.0 else delta_h / aspect_ratio if v1 < 0 : delta_v = max ( delta_v , abs ( v1 ) / top_pad_ratio ) if v2 > img_height : delta_v = max ( delta_v , ( v2 - img_height ) / bottom_pad_ratio ) delta_h = max ( delta_h , delta_v * aspect_ratio ) # Adjust crop values accordingly h1 += delta_h * left_pad_ratio h2 -= delta_h * right_pad_ratio v1 += delta_v * top_pad_ratio v2 -= delta_v * bottom_pad_ratio return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 )] Variables CASCFILE COMBINED_FILETYPES CV2_FILETYPES GAMMA GAMMA_THRES INPUT_FILETYPES MINFACE PILLOW_FILETYPES Functions check_positive_scalar def check_positive_scalar ( num ) Returns True if value if a positive scalar View Source def check_positive_scalar ( num ): \"\"\"Returns True if value if a positive scalar\"\"\" if num > 0 and not isinstance ( num , str ) and np . isscalar ( num ): return int ( num ) raise ValueError ( \"A positive scalar is required\" ) check_underexposed def check_underexposed ( image , gray ) Returns the (cropped) image with GAMMA applied if underexposition is detected. View Source def check_underexposed ( image , gray ) : \"\"\"Returns the (cropped) image with GAMMA applied if underexposition is detected.\"\"\" uexp = cv2 . calcHist ( [ gray ] , [ 0 ] , None , [ 256 ] , [ 0, 256 ] ) if sum ( uexp [ -26: ] ) < GAMMA_THRES * sum ( uexp ) : image = gamma ( image , GAMMA ) return image check_valid_pad_dict def check_valid_pad_dict ( dic ) Returns dic if valid, else raises ValueError View Source def check_valid_pad_dict ( dic ): \"\"\"Returns dic if valid, else raises ValueError\"\"\" valid_keys = { \"pad_top\" , \"pad_right\" , \"pad_bottom\" , \"pad_left\" , } error = \"Padding arguments must use keys {} and be positive scalars\" . format ( valid_keys ) conditions = [] conditions . append ( isinstance ( dic , dict )) conditions . append ( len ( dic ) == 4 ) conditions . append ( set ( dic . keys ()) == valid_keys ) conditions . append ( all ( check_positive_scalar ( n ) for n in dic . values ())) if not all ( conditions ): raise ValueError ( error ) return dic gamma def gamma ( img , correction ) Simple gamma correction to brighten faces View Source def gamma ( img , correction ): \"\"\"Simple gamma correction to brighten faces\"\"\" img = cv2 . pow ( img / 255 . 0 , correction ) return np . uint8 ( img * 255 ) open_file def open_file ( input_filename ) Given a filename, returns a numpy array View Source def open_file ( input_filename ): \"\"\"Given a filename, returns a numpy array\"\"\" extension = os . path . splitext ( input_filename )[ 1 ]. lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None Classes Cropper class Cropper ( width = 500 , height = 500 , padding = 50 , face_percent = 50 , fix_gamma = True ) Crops the largest detected face from images. This class uses the CascadeClassifier from OpenCV to perform the crop by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: width : int, default=500 The width of the resulting array. height : int, default=500 The height of the resulting array. padding: int or dict, default=50 Number of pixels to pad around the largest detected face. Expected padding dict: { \"pad_top\": int, \"pad_right\": int, \"pad_bottom\": int, \"pad_left\": int } face_percent: int, default=50 Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. fix_gamma: bool, default=True Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. View Source class Cropper ( object ): \"\"\" Crops the largest detected face from images. This class uses the CascadeClassifier from OpenCV to perform the `crop` by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: ----------- width : int, default=500 The width of the resulting array. height : int, default=500 The height of the resulting array. padding: int or dict, default=50 Number of pixels to pad around the largest detected face. Expected padding dict: { \" pad_top \": int, \" pad_right \": int, \" pad_bottom \": int, \" pad_left \": int } face_percent: int, default=50 Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. fix_gamma: bool, default=True Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. \"\"\" def __init__ ( self , width = 500 , height = 500 , padding = 50 , face_percent = 50 , fix_gamma = True ): # Size self . height = check_positive_scalar ( height ) self . width = check_positive_scalar ( width ) # Padding if isinstance ( padding , int ): pad = check_positive_scalar ( padding ) self . pad_top = pad self . pad_right = pad self . pad_bottom = pad self . pad_left = pad else : pad = check_valid_pad_dict ( padding ) self . pad_top = pad [ \"pad_top\" ] self . pad_right = pad [ \"pad_right\" ] self . pad_bottom = pad [ \"pad_bottom\" ] self . pad_left = pad [ \"pad_left\" ] # Gamma self . gamma = fix_gamma # Face Percent if face_percent > 100 : fp_error = \"The face_percent argument must be between 0 and 100\" raise ValueError ( fp_error ) self . face_percent = check_positive_scalar ( face_percent ) # XML Resource directory = os . path . dirname ( sys . modules [ \"autocrop\" ]. __file__ ) self . casc_path = os . path . join ( directory , CASCFILE ) def crop ( self , path_or_array ): \"\"\"Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- path_or_array : {str, np.ndarray} The filepath or numpy array of the image. Returns ------- image : {np.ndarray, None} A cropped numpy array if face detected, else None. \"\"\" if isinstance ( path_or_array , str ): image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1 . 1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h ,) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ], pos [ 2 ] : pos [ 3 ]] # Resize image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition if self . gamma : image = check_underexposed ( image , gray ) return image def _crop_positions ( self , img_height , img_width , x , y , w , h , ): \"\"\"Given face coordinates, returns coordinates for which to crop on given padding and face_percent parameters.\"\"\" # Adjust output height based on percent aspect_ratio = float ( self . width ) / float ( self . height ) height_crop = h * 100 . 0 / self . face_percent width_crop = aspect_ratio * float ( height_crop ) # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = float ( x - ( xpad * self . pad_left / ( self . pad_left + self . pad_right ))) h2 = float ( x + w + ( xpad * self . pad_right / ( self . pad_left + self . pad_right ))) v1 = float ( y - ( ypad * self . pad_top / ( self . pad_top + self . pad_bottom ))) v2 = float ( y + h + ( ypad * self . pad_bottom / ( self . pad_top + self . pad_bottom ))) # Determine padding ratios left_pad_ratio = self . pad_left / ( self . pad_left + self . pad_right ) right_pad_ratio = self . pad_left / ( self . pad_left + self . pad_right ) top_pad_ratio = self . pad_top / ( self . pad_top + self . pad_bottom ) bottom_pad_ratio = self . pad_bottom / ( self . pad_top + self . pad_bottom ) # Calculate largest bounds with padding ratios delta_h = 0 . 0 if h1 < 0 : delta_h = abs ( h1 ) / left_pad_ratio if h2 > img_width : delta_h = max ( delta_h , ( h2 - img_width ) / right_pad_ratio ) delta_v = 0 . 0 if delta_h <= 0 . 0 else delta_h / aspect_ratio if v1 < 0 : delta_v = max ( delta_v , abs ( v1 ) / top_pad_ratio ) if v2 > img_height : delta_v = max ( delta_v , ( v2 - img_height ) / bottom_pad_ratio ) delta_h = max ( delta_h , delta_v * aspect_ratio ) # Adjust crop values accordingly h1 += delta_h * left_pad_ratio h2 -= delta_h * right_pad_ratio v1 += delta_v * top_pad_ratio v2 -= delta_v * bottom_pad_ratio return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 )] Methods crop def crop ( self , path_or_array ) Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters path_or_array : {str, np.ndarray} The filepath or numpy array of the image. Returns image : {np.ndarray, None} A cropped numpy array if face detected, else None. View Source def crop ( self , path_or_array ): \"\"\"Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- path_or_array : {str, np.ndarray} The filepath or numpy array of the image. Returns ------- image : {np.ndarray, None} A cropped numpy array if face detected, else None. \"\"\" if isinstance ( path_or_array , str ): image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors , catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1 . 1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h ,) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ], pos [ 2 ] : pos [ 3 ]] # Resize image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition if self . gamma : image = check_underexposed ( image , gray ) return image ImageReadError class ImageReadError ( / , * args , ** kwargs ) Custom exception to catch an OpenCV failure type View Source class ImageReadError ( BaseException ): \"\"\"Custom exception to catch an OpenCV failure type\"\"\" pass Ancestors (in MRO) builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Autocrop"},{"location":"reference/autocrop/autocrop/#module-autocropautocrop","text":"View Source # -*- coding: utf-8 -*- from __future__ import print_function , division import cv2 import numpy as np import os import sys from PIL import Image from .constants import ( MINFACE , GAMMA_THRES , GAMMA , CV2_FILETYPES , PILLOW_FILETYPES , CASCFILE , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] class ImageReadError ( BaseException ): \"\"\"Custom exception to catch an OpenCV failure type\"\"\" pass def gamma ( img , correction ): \"\"\"Simple gamma correction to brighten faces\"\"\" img = cv2 . pow ( img / 255.0 , correction ) return np . uint8 ( img * 255 ) def check_underexposed ( image , gray ): \"\"\"Returns the (cropped) image with GAMMA applied if underexposition is detected.\"\"\" uexp = cv2 . calcHist ([ gray ], [ 0 ], None , [ 256 ], [ 0 , 256 ]) if sum ( uexp [ - 26 :]) < GAMMA_THRES * sum ( uexp ): image = gamma ( image , GAMMA ) return image def check_positive_scalar ( num ): \"\"\"Returns True if value if a positive scalar\"\"\" if num > 0 and not isinstance ( num , str ) and np . isscalar ( num ): return int ( num ) raise ValueError ( \"A positive scalar is required\" ) def check_valid_pad_dict ( dic ): \"\"\"Returns dic if valid, else raises ValueError\"\"\" valid_keys = { \"pad_top\" , \"pad_right\" , \"pad_bottom\" , \"pad_left\" , } error = \"Padding arguments must use keys {} and be positive scalars\" . format ( valid_keys ) conditions = [] conditions . append ( isinstance ( dic , dict )) conditions . append ( len ( dic ) == 4 ) conditions . append ( set ( dic . keys ()) == valid_keys ) conditions . append ( all ( check_positive_scalar ( n ) for n in dic . values ())) if not all ( conditions ): raise ValueError ( error ) return dic def open_file ( input_filename ): \"\"\"Given a filename, returns a numpy array\"\"\" extension = os . path . splitext ( input_filename )[ 1 ] . lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None class Cropper ( object ): \"\"\" Crops the largest detected face from images. This class uses the CascadeClassifier from OpenCV to perform the `crop` by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: ----------- width : int, default=500 The width of the resulting array. height : int, default=500 The height of the resulting array. padding: int or dict, default=50 Number of pixels to pad around the largest detected face. Expected padding dict: { \"pad_top\": int, \"pad_right\": int, \"pad_bottom\": int, \"pad_left\": int } face_percent: int, default=50 Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. fix_gamma: bool, default=True Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. \"\"\" def __init__ ( self , width = 500 , height = 500 , padding = 50 , face_percent = 50 , fix_gamma = True ): # Size self . height = check_positive_scalar ( height ) self . width = check_positive_scalar ( width ) # Padding if isinstance ( padding , int ): pad = check_positive_scalar ( padding ) self . pad_top = pad self . pad_right = pad self . pad_bottom = pad self . pad_left = pad else : pad = check_valid_pad_dict ( padding ) self . pad_top = pad [ \"pad_top\" ] self . pad_right = pad [ \"pad_right\" ] self . pad_bottom = pad [ \"pad_bottom\" ] self . pad_left = pad [ \"pad_left\" ] # Gamma self . gamma = fix_gamma # Face Percent if face_percent > 100 : fp_error = \"The face_percent argument must be between 0 and 100\" raise ValueError ( fp_error ) self . face_percent = check_positive_scalar ( face_percent ) # XML Resource directory = os . path . dirname ( sys . modules [ \"autocrop\" ] . __file__ ) self . casc_path = os . path . join ( directory , CASCFILE ) def crop ( self , path_or_array ): \"\"\"Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- path_or_array : {str, np.ndarray} The filepath or numpy array of the image. Returns ------- image : {np.ndarray, None} A cropped numpy array if face detected, else None. \"\"\" if isinstance ( path_or_array , str ): image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h ,) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ], pos [ 2 ] : pos [ 3 ]] # Resize image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition if self . gamma : image = check_underexposed ( image , gray ) return image def _crop_positions ( self , img_height , img_width , x , y , w , h , ): \"\"\"Given face coordinates, returns coordinates for which to crop on given padding and face_percent parameters.\"\"\" # Adjust output height based on percent aspect_ratio = float ( self . width ) / float ( self . height ) height_crop = h * 100.0 / self . face_percent width_crop = aspect_ratio * float ( height_crop ) # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = float ( x - ( xpad * self . pad_left / ( self . pad_left + self . pad_right ))) h2 = float ( x + w + ( xpad * self . pad_right / ( self . pad_left + self . pad_right ))) v1 = float ( y - ( ypad * self . pad_top / ( self . pad_top + self . pad_bottom ))) v2 = float ( y + h + ( ypad * self . pad_bottom / ( self . pad_top + self . pad_bottom ))) # Determine padding ratios left_pad_ratio = self . pad_left / ( self . pad_left + self . pad_right ) right_pad_ratio = self . pad_left / ( self . pad_left + self . pad_right ) top_pad_ratio = self . pad_top / ( self . pad_top + self . pad_bottom ) bottom_pad_ratio = self . pad_bottom / ( self . pad_top + self . pad_bottom ) # Calculate largest bounds with padding ratios delta_h = 0.0 if h1 < 0 : delta_h = abs ( h1 ) / left_pad_ratio if h2 > img_width : delta_h = max ( delta_h , ( h2 - img_width ) / right_pad_ratio ) delta_v = 0.0 if delta_h <= 0.0 else delta_h / aspect_ratio if v1 < 0 : delta_v = max ( delta_v , abs ( v1 ) / top_pad_ratio ) if v2 > img_height : delta_v = max ( delta_v , ( v2 - img_height ) / bottom_pad_ratio ) delta_h = max ( delta_h , delta_v * aspect_ratio ) # Adjust crop values accordingly h1 += delta_h * left_pad_ratio h2 -= delta_h * right_pad_ratio v1 += delta_v * top_pad_ratio v2 -= delta_v * bottom_pad_ratio return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 )]","title":"Module autocrop.autocrop"},{"location":"reference/autocrop/autocrop/#variables","text":"CASCFILE COMBINED_FILETYPES CV2_FILETYPES GAMMA GAMMA_THRES INPUT_FILETYPES MINFACE PILLOW_FILETYPES","title":"Variables"},{"location":"reference/autocrop/autocrop/#functions","text":"","title":"Functions"},{"location":"reference/autocrop/autocrop/#check_positive_scalar","text":"def check_positive_scalar ( num ) Returns True if value if a positive scalar View Source def check_positive_scalar ( num ): \"\"\"Returns True if value if a positive scalar\"\"\" if num > 0 and not isinstance ( num , str ) and np . isscalar ( num ): return int ( num ) raise ValueError ( \"A positive scalar is required\" )","title":"check_positive_scalar"},{"location":"reference/autocrop/autocrop/#check_underexposed","text":"def check_underexposed ( image , gray ) Returns the (cropped) image with GAMMA applied if underexposition is detected. View Source def check_underexposed ( image , gray ) : \"\"\"Returns the (cropped) image with GAMMA applied if underexposition is detected.\"\"\" uexp = cv2 . calcHist ( [ gray ] , [ 0 ] , None , [ 256 ] , [ 0, 256 ] ) if sum ( uexp [ -26: ] ) < GAMMA_THRES * sum ( uexp ) : image = gamma ( image , GAMMA ) return image","title":"check_underexposed"},{"location":"reference/autocrop/autocrop/#check_valid_pad_dict","text":"def check_valid_pad_dict ( dic ) Returns dic if valid, else raises ValueError View Source def check_valid_pad_dict ( dic ): \"\"\"Returns dic if valid, else raises ValueError\"\"\" valid_keys = { \"pad_top\" , \"pad_right\" , \"pad_bottom\" , \"pad_left\" , } error = \"Padding arguments must use keys {} and be positive scalars\" . format ( valid_keys ) conditions = [] conditions . append ( isinstance ( dic , dict )) conditions . append ( len ( dic ) == 4 ) conditions . append ( set ( dic . keys ()) == valid_keys ) conditions . append ( all ( check_positive_scalar ( n ) for n in dic . values ())) if not all ( conditions ): raise ValueError ( error ) return dic","title":"check_valid_pad_dict"},{"location":"reference/autocrop/autocrop/#gamma","text":"def gamma ( img , correction ) Simple gamma correction to brighten faces View Source def gamma ( img , correction ): \"\"\"Simple gamma correction to brighten faces\"\"\" img = cv2 . pow ( img / 255 . 0 , correction ) return np . uint8 ( img * 255 )","title":"gamma"},{"location":"reference/autocrop/autocrop/#open_file","text":"def open_file ( input_filename ) Given a filename, returns a numpy array View Source def open_file ( input_filename ): \"\"\"Given a filename, returns a numpy array\"\"\" extension = os . path . splitext ( input_filename )[ 1 ]. lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None","title":"open_file"},{"location":"reference/autocrop/autocrop/#classes","text":"","title":"Classes"},{"location":"reference/autocrop/autocrop/#cropper","text":"class Cropper ( width = 500 , height = 500 , padding = 50 , face_percent = 50 , fix_gamma = True ) Crops the largest detected face from images. This class uses the CascadeClassifier from OpenCV to perform the crop by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context.","title":"Cropper"},{"location":"reference/autocrop/autocrop/#parameters","text":"width : int, default=500 The width of the resulting array. height : int, default=500 The height of the resulting array. padding: int or dict, default=50 Number of pixels to pad around the largest detected face. Expected padding dict: { \"pad_top\": int, \"pad_right\": int, \"pad_bottom\": int, \"pad_left\": int } face_percent: int, default=50 Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. fix_gamma: bool, default=True Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. View Source class Cropper ( object ): \"\"\" Crops the largest detected face from images. This class uses the CascadeClassifier from OpenCV to perform the `crop` by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: ----------- width : int, default=500 The width of the resulting array. height : int, default=500 The height of the resulting array. padding: int or dict, default=50 Number of pixels to pad around the largest detected face. Expected padding dict: { \" pad_top \": int, \" pad_right \": int, \" pad_bottom \": int, \" pad_left \": int } face_percent: int, default=50 Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. fix_gamma: bool, default=True Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. \"\"\" def __init__ ( self , width = 500 , height = 500 , padding = 50 , face_percent = 50 , fix_gamma = True ): # Size self . height = check_positive_scalar ( height ) self . width = check_positive_scalar ( width ) # Padding if isinstance ( padding , int ): pad = check_positive_scalar ( padding ) self . pad_top = pad self . pad_right = pad self . pad_bottom = pad self . pad_left = pad else : pad = check_valid_pad_dict ( padding ) self . pad_top = pad [ \"pad_top\" ] self . pad_right = pad [ \"pad_right\" ] self . pad_bottom = pad [ \"pad_bottom\" ] self . pad_left = pad [ \"pad_left\" ] # Gamma self . gamma = fix_gamma # Face Percent if face_percent > 100 : fp_error = \"The face_percent argument must be between 0 and 100\" raise ValueError ( fp_error ) self . face_percent = check_positive_scalar ( face_percent ) # XML Resource directory = os . path . dirname ( sys . modules [ \"autocrop\" ]. __file__ ) self . casc_path = os . path . join ( directory , CASCFILE ) def crop ( self , path_or_array ): \"\"\"Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- path_or_array : {str, np.ndarray} The filepath or numpy array of the image. Returns ------- image : {np.ndarray, None} A cropped numpy array if face detected, else None. \"\"\" if isinstance ( path_or_array , str ): image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1 . 1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h ,) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ], pos [ 2 ] : pos [ 3 ]] # Resize image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition if self . gamma : image = check_underexposed ( image , gray ) return image def _crop_positions ( self , img_height , img_width , x , y , w , h , ): \"\"\"Given face coordinates, returns coordinates for which to crop on given padding and face_percent parameters.\"\"\" # Adjust output height based on percent aspect_ratio = float ( self . width ) / float ( self . height ) height_crop = h * 100 . 0 / self . face_percent width_crop = aspect_ratio * float ( height_crop ) # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = float ( x - ( xpad * self . pad_left / ( self . pad_left + self . pad_right ))) h2 = float ( x + w + ( xpad * self . pad_right / ( self . pad_left + self . pad_right ))) v1 = float ( y - ( ypad * self . pad_top / ( self . pad_top + self . pad_bottom ))) v2 = float ( y + h + ( ypad * self . pad_bottom / ( self . pad_top + self . pad_bottom ))) # Determine padding ratios left_pad_ratio = self . pad_left / ( self . pad_left + self . pad_right ) right_pad_ratio = self . pad_left / ( self . pad_left + self . pad_right ) top_pad_ratio = self . pad_top / ( self . pad_top + self . pad_bottom ) bottom_pad_ratio = self . pad_bottom / ( self . pad_top + self . pad_bottom ) # Calculate largest bounds with padding ratios delta_h = 0 . 0 if h1 < 0 : delta_h = abs ( h1 ) / left_pad_ratio if h2 > img_width : delta_h = max ( delta_h , ( h2 - img_width ) / right_pad_ratio ) delta_v = 0 . 0 if delta_h <= 0 . 0 else delta_h / aspect_ratio if v1 < 0 : delta_v = max ( delta_v , abs ( v1 ) / top_pad_ratio ) if v2 > img_height : delta_v = max ( delta_v , ( v2 - img_height ) / bottom_pad_ratio ) delta_h = max ( delta_h , delta_v * aspect_ratio ) # Adjust crop values accordingly h1 += delta_h * left_pad_ratio h2 -= delta_h * right_pad_ratio v1 += delta_v * top_pad_ratio v2 -= delta_v * bottom_pad_ratio return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 )]","title":"Parameters:"},{"location":"reference/autocrop/autocrop/#methods","text":"","title":"Methods"},{"location":"reference/autocrop/autocrop/#crop","text":"def crop ( self , path_or_array ) Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face.","title":"crop"},{"location":"reference/autocrop/autocrop/#parameters_1","text":"path_or_array : {str, np.ndarray} The filepath or numpy array of the image.","title":"Parameters"},{"location":"reference/autocrop/autocrop/#returns","text":"image : {np.ndarray, None} A cropped numpy array if face detected, else None. View Source def crop ( self , path_or_array ): \"\"\"Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- path_or_array : {str, np.ndarray} The filepath or numpy array of the image. Returns ------- image : {np.ndarray, None} A cropped numpy array if face detected, else None. \"\"\" if isinstance ( path_or_array , str ): image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors , catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1 . 1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h ,) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ], pos [ 2 ] : pos [ 3 ]] # Resize image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition if self . gamma : image = check_underexposed ( image , gray ) return image","title":"Returns"},{"location":"reference/autocrop/autocrop/#imagereaderror","text":"class ImageReadError ( / , * args , ** kwargs ) Custom exception to catch an OpenCV failure type View Source class ImageReadError ( BaseException ): \"\"\"Custom exception to catch an OpenCV failure type\"\"\" pass","title":"ImageReadError"},{"location":"reference/autocrop/autocrop/#ancestors-in-mro","text":"builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/autocrop/autocrop/#class-variables","text":"args","title":"Class variables"},{"location":"reference/autocrop/autocrop/#methods_1","text":"","title":"Methods"},{"location":"reference/autocrop/autocrop/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/autocrop/cli/","text":"Module autocrop.cli View Source # -*- coding: utf-8 -*- from __future__ import print_function , division import argparse import cv2 import io import os import shutil import sys from PIL import Image from .__version__ import __version__ from .autocrop import Cropper , ImageReadError from .constants import ( QUESTION_OVERWRITE , CV2_FILETYPES , PILLOW_FILETYPES , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] def check_padding_value ( num ): \"\"\"Returns original value if positive scalar, else returns 50\"\"\" # For CLI backwards compatibility; Cropper already checks input if num is False or num < 0 : return 50 return num def output ( input_filename , output_filename , image ): \"\"\"Move the input file to the output location and write over it with the cropped image data.\"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . move ( input_filename , output_filename ) # Encode the image as an in-memory PNG img_png = cv2 . imencode ( \".png\" , image )[ 1 ] . tostring () # Read the PNG data img_new = Image . open ( io . BytesIO ( img_png )) # Write the new image (converting the format to match the output # filename if necessary) img_new . save ( output_filename ) def reject ( input_filename , reject_filename ): \"\"\"Move the input file to the reject location.\"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . move ( input_filename , reject_filename ) def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ): \"\"\"Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Make padding dict padding = { \"pad_top\" : check_padding_value ( padUp ), \"pad_right\" : check_padding_value ( padRight ), \"pad_bottom\" : check_padding_value ( padDown ), \"pad_left\" : check_padding_value ( padLeft ), } # Main loop cropper = Cropper ( width = fwidth , height = fheight , padding = padding , face_percent = facePercent ) for input_filename in input_files : basename = os . path . basename ( input_filename ) output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) image = None # Attempt the crop try : image = cropper . crop ( input_filename ) except ImageReadError : print ( \"Read error: {}\" . format ( input_filename )) continue # Did the crop produce an invalid image? if isinstance ( image , type ( None )): reject ( input_filename , reject_filename ) print ( \"No face detected: {}\" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {}\" . format ( output_filename )) output_count += 1 # Stop and print status print ( \"{} input files, {} faces cropped, {} rejected\" . format ( input_count , output_count , reject_count ) ) def input_path ( p ): \"\"\"Returns path, only if input is a valid directory\"\"\" no_folder = \"Input folder does not exist\" no_images = \"Input folder does not contain any image files\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): raise argparse . ArgumentTypeError ( no_folder ) filetypes = set ( os . path . splitext ( f )[ - 1 ] for f in os . listdir ( p )) if not any ( t in INPUT_FILETYPES for t in filetypes ): raise argparse . ArgumentTypeError ( no_images ) else : return p def output_path ( p ): \"\"\"Returns path, if input is a valid directory name. If directory doesn't exist, creates it.\"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): os . makedirs ( p ) return p def size ( i ): \"\"\"Returns valid only if input is a positive integer under 1e5\"\"\" error = \"Invalid pixel size\" try : i = int ( i ) except ValueError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1e5 : return i else : raise argparse . ArgumentTypeError ( error ) def compat_input ( s = \"\" ): # pragma: no cover \"\"\"Compatibility function to permit testing for Python 2 and 3\"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input() renamed to input() in Py3 return input ( s ) # lgtm[py/use-of-input] def confirmation ( question ): \"\"\"Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. \"\"\" yes_list = [ \"yes\" , \"y\" ] no_list = [ \"no\" , \"n\" ] default_str = \"[Y]/n\" prompt_str = \" %s %s \" % ( question , default_str ) while True : choice = compat_input ( prompt_str ) . lower () if not choice : return default_str if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str ) def parse_args ( args ): help_d = { \"desc\" : \"Automatically crops faces from batches of pictures\" , \"input\" : \"\"\"Folder where images to crop are located. Default: current working directory\"\"\" , \"output\" : \"\"\"Folder where cropped images will be moved to. Default: current working directory, meaning images are cropped in place.\"\"\" , \"reject\" : \"\"\"Folder where images that could not be cropped will be moved to. Default: current working directory, meaning images that are not cropped will be left in place.\"\"\" , \"width\" : \"Width of cropped files in px. Default=500\" , \"height\" : \"Height of cropped files in px. Default=500\" , \"y\" : \"Bypass any confirmation prompts\" , \"facePercent\" : \"Percentage of face to image height\" , \"padUp\" : \"Add padding up to face cropped\" , \"padDown\" : \"Add padding down to face cropped\" , \"padLeft\" : \"Add padding left to face cropped\" , \"padRight\" : \"Add padding right to face cropped\" , } parser = argparse . ArgumentParser ( description = help_d [ \"desc\" ]) parser . add_argument ( \"-i\" , \"--input\" , default = \".\" , type = input_path , help = help_d [ \"input\" ] ) parser . add_argument ( \"-o\" , \"--output\" , \"-p\" , \"--path\" , type = output_path , default = None , help = help_d [ \"output\" ], ) parser . add_argument ( \"-r\" , \"--reject\" , type = output_path , default = None , help = help_d [ \"reject\" ] ) parser . add_argument ( \"-w\" , \"--width\" , type = size , default = 500 , help = help_d [ \"width\" ]) parser . add_argument ( \"-H\" , \"--height\" , type = size , default = 500 , help = help_d [ \"height\" ]) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \" %(prog)s version {}\" . format ( __version__ ), ) parser . add_argument ( \"--no-confirm\" , action = \"store_true\" , help = help_d [ \"y\" ]) parser . add_argument ( \"--padUp\" , type = size , default = False , help = help_d [ \"padUp\" ]) parser . add_argument ( \"--padDown\" , type = size , default = False , help = help_d [ \"padDown\" ]) parser . add_argument ( \"--padLeft\" , type = size , default = False , help = help_d [ \"padLeft\" ]) parser . add_argument ( \"--padRight\" , type = size , default = False , help = help_d [ \"padRight\" ]) parser . add_argument ( \"--facePercent\" , type = size , default = 50 , help = help_d [ \"facePercent\" ] ) return parser . parse_args () def command_line_interface (): args = parse_args ( sys . argv [ 1 :]) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ): sys . exit () if args . input == args . output : args . output = None print ( \"Processing images in folder:\" , args . input ) main ( args . input , args . output , args . reject , args . height , args . width , args . facePercent , args . padUp , args . padDown , args . padLeft , args . padRight , ) Variables COMBINED_FILETYPES CV2_FILETYPES INPUT_FILETYPES PILLOW_FILETYPES QUESTION_OVERWRITE Functions check_padding_value def check_padding_value ( num ) Returns original value if positive scalar, else returns 50 View Source def check_padding_value ( num ): \"\"\"Returns original value if positive scalar, else returns 50\"\"\" # For CLI backwards compatibility ; Cropper already checks input if num is False or num < 0 : return 50 return num command_line_interface def command_line_interface ( ) View Source def command_line_interface (): args = parse_args ( sys . argv [ 1 :]) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ): sys . exit () if args . input == args . output : args . output = None print ( \"Processing images in folder:\" , args . input ) main ( args . input , args . output , args . reject , args . height , args . width , args . facePercent , args . padUp , args . padDown , args . padLeft , args . padRight , ) compat_input def compat_input ( s = '' ) Compatibility function to permit testing for Python 2 and 3 View Source def compat_input ( s = \"\" ): # pragma : no cover \"\"\"Compatibility function to permit testing for Python 2 and 3\"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input () renamed to input () in Py3 return input ( s ) # lgtm [ py / use - of - input ] confirmation def confirmation ( question ) Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. View Source def confirmation ( question ) : \"\"\"Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. \"\"\" yes_list = [ \"yes\", \"y\" ] no_list = [ \"no\", \"n\" ] default_str = \"[Y]/n\" prompt_str = \"%s %s \" % ( question , default_str ) while True : choice = compat_input ( prompt_str ). lower () if not choice : return default_str if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str ) input_path def input_path ( p ) Returns path, only if input is a valid directory View Source def input_path ( p ): \"\"\"Returns path, only if input is a valid directory\"\"\" no_folder = \"Input folder does not exist\" no_images = \"Input folder does not contain any image files\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): raise argparse . ArgumentTypeError ( no_folder ) filetypes = set ( os . path . splitext ( f )[ - 1 ] for f in os . listdir ( p )) if not any ( t in INPUT_FILETYPES for t in filetypes ): raise argparse . ArgumentTypeError ( no_images ) else : return p main def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False ) Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None View Source def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ): \"\"\"Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Make padding dict padding = { \"pad_top\" : check_padding_value ( padUp ), \"pad_right\" : check_padding_value ( padRight ), \"pad_bottom\" : check_padding_value ( padDown ), \"pad_left\" : check_padding_value ( padLeft ), } # Main loop cropper = Cropper ( width = fwidth , height = fheight , padding = padding , face_percent = facePercent ) for input_filename in input_files : basename = os . path . basename ( input_filename ) output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) image = None # Attempt the crop try : image = cropper . crop ( input_filename ) except ImageReadError : print ( \"Read error: {}\" . format ( input_filename )) continue # Did the crop produce an invalid image ? if isinstance ( image , type ( None )): reject ( input_filename , reject_filename ) print ( \"No face detected: {}\" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {}\" . format ( output_filename )) output_count += 1 # Stop and print status print ( \"{} input files, {} faces cropped, {} rejected\" . format ( input_count , output_count , reject_count ) ) output def output ( input_filename , output_filename , image ) Move the input file to the output location and write over it with the cropped image data. View Source def output ( input_filename , output_filename , image ): \"\"\"Move the input file to the output location and write over it with the cropped image data.\"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . move ( input_filename , output_filename ) # Encode the image as an in - memory PNG img_png = cv2 . imencode ( \".png\" , image )[ 1 ]. tostring () # Read the PNG data img_new = Image . open ( io . BytesIO ( img_png )) # Write the new image ( converting the format to match the output # filename if necessary ) img_new . save ( output_filename ) output_path def output_path ( p ) Returns path, if input is a valid directory name. If directory doesn't exist, creates it. View Source def output_path ( p ): \"\"\"Returns path, if input is a valid directory name. If directory doesn't exist, creates it.\"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): os . makedirs ( p ) return p parse_args def parse_args ( args ) View Source def parse_args ( args ): help_d = { \"desc\" : \"Automatically crops faces from batches of pictures\" , \"input\" : \"\"\"Folder where images to crop are located. Default: current working directory\"\"\" , \"output\" : \"\"\"Folder where cropped images will be moved to. Default: current working directory, meaning images are cropped in place.\"\"\" , \"reject\" : \"\"\"Folder where images that could not be cropped will be moved to. Default: current working directory, meaning images that are not cropped will be left in place.\"\"\" , \"width\" : \"Width of cropped files in px. Default=500\" , \"height\" : \"Height of cropped files in px. Default=500\" , \"y\" : \"Bypass any confirmation prompts\" , \"facePercent\" : \"Percentage of face to image height\" , \"padUp\" : \"Add padding up to face cropped\" , \"padDown\" : \"Add padding down to face cropped\" , \"padLeft\" : \"Add padding left to face cropped\" , \"padRight\" : \"Add padding right to face cropped\" , } parser = argparse . ArgumentParser ( description = help_d [ \"desc\" ]) parser . add_argument ( \"-i\" , \"--input\" , default = \".\" , type = input_path , help = help_d [ \"input\" ] ) parser . add_argument ( \"-o\" , \"--output\" , \"-p\" , \"--path\" , type = output_path , default = None , help = help_d [ \"output\" ], ) parser . add_argument ( \"-r\" , \"--reject\" , type = output_path , default = None , help = help_d [ \"reject\" ] ) parser . add_argument ( \"-w\" , \"--width\" , type = size , default = 500 , help = help_d [ \"width\" ]) parser . add_argument ( \"-H\" , \"--height\" , type = size , default = 500 , help = help_d [ \"height\" ]) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \"%(prog)s version {}\" . format ( __version__ ), ) parser . add_argument ( \"--no-confirm\" , action = \"store_true\" , help = help_d [ \"y\" ]) parser . add_argument ( \"--padUp\" , type = size , default = False , help = help_d [ \"padUp\" ]) parser . add_argument ( \"--padDown\" , type = size , default = False , help = help_d [ \"padDown\" ]) parser . add_argument ( \"--padLeft\" , type = size , default = False , help = help_d [ \"padLeft\" ]) parser . add_argument ( \"--padRight\" , type = size , default = False , help = help_d [ \"padRight\" ]) parser . add_argument ( \"--facePercent\" , type = size , default = 50 , help = help_d [ \"facePercent\" ] ) return parser . parse_args () reject def reject ( input_filename , reject_filename ) Move the input file to the reject location. View Source def reject ( input_filename , reject_filename ): \"\"\"Move the input file to the reject location.\"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . move ( input_filename , reject_filename ) size def size ( i ) Returns valid only if input is a positive integer under 1e5 View Source def size ( i ): \"\"\"Returns valid only if input is a positive integer under 1e5\"\"\" error = \"Invalid pixel size\" try : i = int ( i ) except ValueError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1 e5 : return i else : raise argparse . ArgumentTypeError ( error )","title":"CLI"},{"location":"reference/autocrop/cli/#module-autocropcli","text":"View Source # -*- coding: utf-8 -*- from __future__ import print_function , division import argparse import cv2 import io import os import shutil import sys from PIL import Image from .__version__ import __version__ from .autocrop import Cropper , ImageReadError from .constants import ( QUESTION_OVERWRITE , CV2_FILETYPES , PILLOW_FILETYPES , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] def check_padding_value ( num ): \"\"\"Returns original value if positive scalar, else returns 50\"\"\" # For CLI backwards compatibility; Cropper already checks input if num is False or num < 0 : return 50 return num def output ( input_filename , output_filename , image ): \"\"\"Move the input file to the output location and write over it with the cropped image data.\"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . move ( input_filename , output_filename ) # Encode the image as an in-memory PNG img_png = cv2 . imencode ( \".png\" , image )[ 1 ] . tostring () # Read the PNG data img_new = Image . open ( io . BytesIO ( img_png )) # Write the new image (converting the format to match the output # filename if necessary) img_new . save ( output_filename ) def reject ( input_filename , reject_filename ): \"\"\"Move the input file to the reject location.\"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . move ( input_filename , reject_filename ) def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ): \"\"\"Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Make padding dict padding = { \"pad_top\" : check_padding_value ( padUp ), \"pad_right\" : check_padding_value ( padRight ), \"pad_bottom\" : check_padding_value ( padDown ), \"pad_left\" : check_padding_value ( padLeft ), } # Main loop cropper = Cropper ( width = fwidth , height = fheight , padding = padding , face_percent = facePercent ) for input_filename in input_files : basename = os . path . basename ( input_filename ) output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) image = None # Attempt the crop try : image = cropper . crop ( input_filename ) except ImageReadError : print ( \"Read error: {}\" . format ( input_filename )) continue # Did the crop produce an invalid image? if isinstance ( image , type ( None )): reject ( input_filename , reject_filename ) print ( \"No face detected: {}\" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {}\" . format ( output_filename )) output_count += 1 # Stop and print status print ( \"{} input files, {} faces cropped, {} rejected\" . format ( input_count , output_count , reject_count ) ) def input_path ( p ): \"\"\"Returns path, only if input is a valid directory\"\"\" no_folder = \"Input folder does not exist\" no_images = \"Input folder does not contain any image files\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): raise argparse . ArgumentTypeError ( no_folder ) filetypes = set ( os . path . splitext ( f )[ - 1 ] for f in os . listdir ( p )) if not any ( t in INPUT_FILETYPES for t in filetypes ): raise argparse . ArgumentTypeError ( no_images ) else : return p def output_path ( p ): \"\"\"Returns path, if input is a valid directory name. If directory doesn't exist, creates it.\"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): os . makedirs ( p ) return p def size ( i ): \"\"\"Returns valid only if input is a positive integer under 1e5\"\"\" error = \"Invalid pixel size\" try : i = int ( i ) except ValueError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1e5 : return i else : raise argparse . ArgumentTypeError ( error ) def compat_input ( s = \"\" ): # pragma: no cover \"\"\"Compatibility function to permit testing for Python 2 and 3\"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input() renamed to input() in Py3 return input ( s ) # lgtm[py/use-of-input] def confirmation ( question ): \"\"\"Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. \"\"\" yes_list = [ \"yes\" , \"y\" ] no_list = [ \"no\" , \"n\" ] default_str = \"[Y]/n\" prompt_str = \" %s %s \" % ( question , default_str ) while True : choice = compat_input ( prompt_str ) . lower () if not choice : return default_str if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str ) def parse_args ( args ): help_d = { \"desc\" : \"Automatically crops faces from batches of pictures\" , \"input\" : \"\"\"Folder where images to crop are located. Default: current working directory\"\"\" , \"output\" : \"\"\"Folder where cropped images will be moved to. Default: current working directory, meaning images are cropped in place.\"\"\" , \"reject\" : \"\"\"Folder where images that could not be cropped will be moved to. Default: current working directory, meaning images that are not cropped will be left in place.\"\"\" , \"width\" : \"Width of cropped files in px. Default=500\" , \"height\" : \"Height of cropped files in px. Default=500\" , \"y\" : \"Bypass any confirmation prompts\" , \"facePercent\" : \"Percentage of face to image height\" , \"padUp\" : \"Add padding up to face cropped\" , \"padDown\" : \"Add padding down to face cropped\" , \"padLeft\" : \"Add padding left to face cropped\" , \"padRight\" : \"Add padding right to face cropped\" , } parser = argparse . ArgumentParser ( description = help_d [ \"desc\" ]) parser . add_argument ( \"-i\" , \"--input\" , default = \".\" , type = input_path , help = help_d [ \"input\" ] ) parser . add_argument ( \"-o\" , \"--output\" , \"-p\" , \"--path\" , type = output_path , default = None , help = help_d [ \"output\" ], ) parser . add_argument ( \"-r\" , \"--reject\" , type = output_path , default = None , help = help_d [ \"reject\" ] ) parser . add_argument ( \"-w\" , \"--width\" , type = size , default = 500 , help = help_d [ \"width\" ]) parser . add_argument ( \"-H\" , \"--height\" , type = size , default = 500 , help = help_d [ \"height\" ]) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \" %(prog)s version {}\" . format ( __version__ ), ) parser . add_argument ( \"--no-confirm\" , action = \"store_true\" , help = help_d [ \"y\" ]) parser . add_argument ( \"--padUp\" , type = size , default = False , help = help_d [ \"padUp\" ]) parser . add_argument ( \"--padDown\" , type = size , default = False , help = help_d [ \"padDown\" ]) parser . add_argument ( \"--padLeft\" , type = size , default = False , help = help_d [ \"padLeft\" ]) parser . add_argument ( \"--padRight\" , type = size , default = False , help = help_d [ \"padRight\" ]) parser . add_argument ( \"--facePercent\" , type = size , default = 50 , help = help_d [ \"facePercent\" ] ) return parser . parse_args () def command_line_interface (): args = parse_args ( sys . argv [ 1 :]) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ): sys . exit () if args . input == args . output : args . output = None print ( \"Processing images in folder:\" , args . input ) main ( args . input , args . output , args . reject , args . height , args . width , args . facePercent , args . padUp , args . padDown , args . padLeft , args . padRight , )","title":"Module autocrop.cli"},{"location":"reference/autocrop/cli/#variables","text":"COMBINED_FILETYPES CV2_FILETYPES INPUT_FILETYPES PILLOW_FILETYPES QUESTION_OVERWRITE","title":"Variables"},{"location":"reference/autocrop/cli/#functions","text":"","title":"Functions"},{"location":"reference/autocrop/cli/#check_padding_value","text":"def check_padding_value ( num ) Returns original value if positive scalar, else returns 50 View Source def check_padding_value ( num ): \"\"\"Returns original value if positive scalar, else returns 50\"\"\" # For CLI backwards compatibility ; Cropper already checks input if num is False or num < 0 : return 50 return num","title":"check_padding_value"},{"location":"reference/autocrop/cli/#command_line_interface","text":"def command_line_interface ( ) View Source def command_line_interface (): args = parse_args ( sys . argv [ 1 :]) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ): sys . exit () if args . input == args . output : args . output = None print ( \"Processing images in folder:\" , args . input ) main ( args . input , args . output , args . reject , args . height , args . width , args . facePercent , args . padUp , args . padDown , args . padLeft , args . padRight , )","title":"command_line_interface"},{"location":"reference/autocrop/cli/#compat_input","text":"def compat_input ( s = '' ) Compatibility function to permit testing for Python 2 and 3 View Source def compat_input ( s = \"\" ): # pragma : no cover \"\"\"Compatibility function to permit testing for Python 2 and 3\"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input () renamed to input () in Py3 return input ( s ) # lgtm [ py / use - of - input ]","title":"compat_input"},{"location":"reference/autocrop/cli/#confirmation","text":"def confirmation ( question ) Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. View Source def confirmation ( question ) : \"\"\"Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. \"\"\" yes_list = [ \"yes\", \"y\" ] no_list = [ \"no\", \"n\" ] default_str = \"[Y]/n\" prompt_str = \"%s %s \" % ( question , default_str ) while True : choice = compat_input ( prompt_str ). lower () if not choice : return default_str if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str )","title":"confirmation"},{"location":"reference/autocrop/cli/#input_path","text":"def input_path ( p ) Returns path, only if input is a valid directory View Source def input_path ( p ): \"\"\"Returns path, only if input is a valid directory\"\"\" no_folder = \"Input folder does not exist\" no_images = \"Input folder does not contain any image files\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): raise argparse . ArgumentTypeError ( no_folder ) filetypes = set ( os . path . splitext ( f )[ - 1 ] for f in os . listdir ( p )) if not any ( t in INPUT_FILETYPES for t in filetypes ): raise argparse . ArgumentTypeError ( no_images ) else : return p","title":"input_path"},{"location":"reference/autocrop/cli/#main","text":"def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False ) Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None View Source def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ): \"\"\"Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Make padding dict padding = { \"pad_top\" : check_padding_value ( padUp ), \"pad_right\" : check_padding_value ( padRight ), \"pad_bottom\" : check_padding_value ( padDown ), \"pad_left\" : check_padding_value ( padLeft ), } # Main loop cropper = Cropper ( width = fwidth , height = fheight , padding = padding , face_percent = facePercent ) for input_filename in input_files : basename = os . path . basename ( input_filename ) output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) image = None # Attempt the crop try : image = cropper . crop ( input_filename ) except ImageReadError : print ( \"Read error: {}\" . format ( input_filename )) continue # Did the crop produce an invalid image ? if isinstance ( image , type ( None )): reject ( input_filename , reject_filename ) print ( \"No face detected: {}\" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {}\" . format ( output_filename )) output_count += 1 # Stop and print status print ( \"{} input files, {} faces cropped, {} rejected\" . format ( input_count , output_count , reject_count ) )","title":"main"},{"location":"reference/autocrop/cli/#output","text":"def output ( input_filename , output_filename , image ) Move the input file to the output location and write over it with the cropped image data. View Source def output ( input_filename , output_filename , image ): \"\"\"Move the input file to the output location and write over it with the cropped image data.\"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . move ( input_filename , output_filename ) # Encode the image as an in - memory PNG img_png = cv2 . imencode ( \".png\" , image )[ 1 ]. tostring () # Read the PNG data img_new = Image . open ( io . BytesIO ( img_png )) # Write the new image ( converting the format to match the output # filename if necessary ) img_new . save ( output_filename )","title":"output"},{"location":"reference/autocrop/cli/#output_path","text":"def output_path ( p ) Returns path, if input is a valid directory name. If directory doesn't exist, creates it. View Source def output_path ( p ): \"\"\"Returns path, if input is a valid directory name. If directory doesn't exist, creates it.\"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): os . makedirs ( p ) return p","title":"output_path"},{"location":"reference/autocrop/cli/#parse_args","text":"def parse_args ( args ) View Source def parse_args ( args ): help_d = { \"desc\" : \"Automatically crops faces from batches of pictures\" , \"input\" : \"\"\"Folder where images to crop are located. Default: current working directory\"\"\" , \"output\" : \"\"\"Folder where cropped images will be moved to. Default: current working directory, meaning images are cropped in place.\"\"\" , \"reject\" : \"\"\"Folder where images that could not be cropped will be moved to. Default: current working directory, meaning images that are not cropped will be left in place.\"\"\" , \"width\" : \"Width of cropped files in px. Default=500\" , \"height\" : \"Height of cropped files in px. Default=500\" , \"y\" : \"Bypass any confirmation prompts\" , \"facePercent\" : \"Percentage of face to image height\" , \"padUp\" : \"Add padding up to face cropped\" , \"padDown\" : \"Add padding down to face cropped\" , \"padLeft\" : \"Add padding left to face cropped\" , \"padRight\" : \"Add padding right to face cropped\" , } parser = argparse . ArgumentParser ( description = help_d [ \"desc\" ]) parser . add_argument ( \"-i\" , \"--input\" , default = \".\" , type = input_path , help = help_d [ \"input\" ] ) parser . add_argument ( \"-o\" , \"--output\" , \"-p\" , \"--path\" , type = output_path , default = None , help = help_d [ \"output\" ], ) parser . add_argument ( \"-r\" , \"--reject\" , type = output_path , default = None , help = help_d [ \"reject\" ] ) parser . add_argument ( \"-w\" , \"--width\" , type = size , default = 500 , help = help_d [ \"width\" ]) parser . add_argument ( \"-H\" , \"--height\" , type = size , default = 500 , help = help_d [ \"height\" ]) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \"%(prog)s version {}\" . format ( __version__ ), ) parser . add_argument ( \"--no-confirm\" , action = \"store_true\" , help = help_d [ \"y\" ]) parser . add_argument ( \"--padUp\" , type = size , default = False , help = help_d [ \"padUp\" ]) parser . add_argument ( \"--padDown\" , type = size , default = False , help = help_d [ \"padDown\" ]) parser . add_argument ( \"--padLeft\" , type = size , default = False , help = help_d [ \"padLeft\" ]) parser . add_argument ( \"--padRight\" , type = size , default = False , help = help_d [ \"padRight\" ]) parser . add_argument ( \"--facePercent\" , type = size , default = 50 , help = help_d [ \"facePercent\" ] ) return parser . parse_args ()","title":"parse_args"},{"location":"reference/autocrop/cli/#reject","text":"def reject ( input_filename , reject_filename ) Move the input file to the reject location. View Source def reject ( input_filename , reject_filename ): \"\"\"Move the input file to the reject location.\"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . move ( input_filename , reject_filename )","title":"reject"},{"location":"reference/autocrop/cli/#size","text":"def size ( i ) Returns valid only if input is a positive integer under 1e5 View Source def size ( i ): \"\"\"Returns valid only if input is a positive integer under 1e5\"\"\" error = \"Invalid pixel size\" try : i = int ( i ) except ValueError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1 e5 : return i else : raise argparse . ArgumentTypeError ( error )","title":"size"},{"location":"reference/autocrop/constants/","text":"Module autocrop.constants View Source # -*- coding : utf - 8 -*- FIXEXP = True # Flag to fix underexposition MINFACE = 8 # Minimum face size ratio ; too low and we get false positives INCREMENT = 0 . 06 GAMMA_THRES = 0 . 001 GAMMA = 0 . 90 FACE_RATIO = 6 # Face / padding ratio QUESTION_OVERWRITE = \"Overwrite image files?\" # File types supported by OpenCV CV2_FILETYPES = [ \".bmp\" , \".dib\" , \".jp2\" , \".jpe\" , \".jpeg\" , \".jpg\" , \".pbm\" , \".pgm\" , \".png\" , \".ppm\" , \".ras\" , \".sr\" , \".tif\" , \".tiff\" , \".webp\" , ] # File types supported by Pillow PILLOW_FILETYPES = [ \".eps\" , \".gif\" , \".icns\" , \".ico\" , \".im\" , \".msp\" , \".pcx\" , \".sgi\" , \".spi\" , \".xbm\" , ] CASCFILE = \"haarcascade_frontalface_default.xml\" Variables CASCFILE CV2_FILETYPES FACE_RATIO FIXEXP GAMMA GAMMA_THRES INCREMENT MINFACE PILLOW_FILETYPES QUESTION_OVERWRITE","title":"Constants"},{"location":"reference/autocrop/constants/#module-autocropconstants","text":"View Source # -*- coding : utf - 8 -*- FIXEXP = True # Flag to fix underexposition MINFACE = 8 # Minimum face size ratio ; too low and we get false positives INCREMENT = 0 . 06 GAMMA_THRES = 0 . 001 GAMMA = 0 . 90 FACE_RATIO = 6 # Face / padding ratio QUESTION_OVERWRITE = \"Overwrite image files?\" # File types supported by OpenCV CV2_FILETYPES = [ \".bmp\" , \".dib\" , \".jp2\" , \".jpe\" , \".jpeg\" , \".jpg\" , \".pbm\" , \".pgm\" , \".png\" , \".ppm\" , \".ras\" , \".sr\" , \".tif\" , \".tiff\" , \".webp\" , ] # File types supported by Pillow PILLOW_FILETYPES = [ \".eps\" , \".gif\" , \".icns\" , \".ico\" , \".im\" , \".msp\" , \".pcx\" , \".sgi\" , \".spi\" , \".xbm\" , ] CASCFILE = \"haarcascade_frontalface_default.xml\"","title":"Module autocrop.constants"},{"location":"reference/autocrop/constants/#variables","text":"CASCFILE CV2_FILETYPES FACE_RATIO FIXEXP GAMMA GAMMA_THRES INCREMENT MINFACE PILLOW_FILETYPES QUESTION_OVERWRITE","title":"Variables"}]}